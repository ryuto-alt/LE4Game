# フルスクリーン実装方法

このドキュメントでは、UnoEngineにおけるフルスクリーン機能の実装方法を説明します。

## 概要

UnoEngineでは、ボーダーレスウィンドウ方式を使用してフルスクリーン機能を実装しています。これにより、高速な切り替えと互換性の高い動作を実現しています。

## 実装ファイル

フルスクリーン機能は以下のファイルに実装されています：

- **ヘッダーファイル**: `src/Engine/Utility/WinApp.h`
- **実装ファイル**: `src/Engine/Utility/WinApp.cpp`
- **エンジン統合**: `src/Engine/UnoEngine.cpp`

## 実装の詳細

### 1. WinApp.h - クラス定義

```cpp
class WinApp {
public:
    // フルスクリーン切り替え
    void ToggleFullscreen();
    bool IsFullscreen() const { return isFullscreen_; }

private:
    // フルスクリーン関連
    bool isFullscreen_ = false;
    RECT windowedRect_ = {};
    LONG windowedStyle_ = 0;
};
```

**重要なメンバ変数:**
- `isFullscreen_`: 現在フルスクリーン状態かどうかを保持
- `windowedRect_`: ウィンドウモード時の位置とサイズを保存
- `windowedStyle_`: ウィンドウモード時のウィンドウスタイルを保存

### 2. WinApp.cpp - フルスクリーン切り替え実装

#### ウィンドウモード → フルスクリーン

```cpp
void WinApp::ToggleFullscreen() {
    if (!isFullscreen_) {
        // 1. 現在のウィンドウスタイルと位置を保存
        windowedStyle_ = GetWindowLong(hwnd, GWL_STYLE);
        GetWindowRect(hwnd, &windowedRect_);

        // 2. ウィンドウスタイルを変更（枠なし、最大化ボタンなし）
        SetWindowLong(hwnd, GWL_STYLE, WS_VISIBLE | WS_POPUP);

        // 3. モニター情報を取得
        HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTOPRIMARY);
        MONITORINFO monitorInfo = { sizeof(MONITORINFO) };
        GetMonitorInfo(hMonitor, &monitorInfo);

        // 4. フルスクリーンサイズに変更（モニターの作業領域全体）
        SetWindowPos(hwnd, HWND_TOPMOST,
            monitorInfo.rcMonitor.left,
            monitorInfo.rcMonitor.top,
            monitorInfo.rcMonitor.right - monitorInfo.rcMonitor.left,
            monitorInfo.rcMonitor.bottom - monitorInfo.rcMonitor.top,
            SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        isFullscreen_ = true;
    }
}
```

**処理の流れ:**
1. 現在のウィンドウスタイルと矩形（位置・サイズ）を保存
2. ウィンドウスタイルを`WS_VISIBLE | WS_POPUP`に変更（枠なし）
3. `MonitorFromWindow`でモニター情報を取得
4. `SetWindowPos`でウィンドウを最前面（`HWND_TOPMOST`）かつモニター全体に拡張

#### フルスクリーン → ウィンドウモード

```cpp
void WinApp::ToggleFullscreen() {
    // ...
    else {
        // 1. 元のウィンドウスタイルに戻す
        SetWindowLong(hwnd, GWL_STYLE, windowedStyle_);

        // 2. 元のサイズと位置に戻す（HWND_NOTOPMOSTで最前面から外す）
        SetWindowPos(hwnd, HWND_NOTOPMOST,
            windowedRect_.left,
            windowedRect_.top,
            windowedRect_.right - windowedRect_.left,
            windowedRect_.bottom - windowedRect_.top,
            SWP_FRAMECHANGED | SWP_SHOWWINDOW);

        isFullscreen_ = false;
    }
}
```

**処理の流れ:**
1. 保存しておいた元のウィンドウスタイルを復元
2. `SetWindowPos`で元の位置・サイズに戻し、最前面から外す（`HWND_NOTOPMOST`）

### 3. UnoEngine.cpp - キーボード入力による切り替え

```cpp
void UnoEngine::Update() {
    // ...

    // F11キーでフルスクリーン切り替え
    if (input_->TriggerKey(DIK_F11)) {
        winApp_->ToggleFullscreen();
    }

    // ...
}
```

エンジンの更新ループ内で、F11キーが押されたときに`ToggleFullscreen()`を呼び出します。

## 使用方法

### ゲームコード内での使用

```cpp
// 現在の状態を取得
bool isFullscreen = engine->GetWinApp()->IsFullscreen();

// プログラムからフルスクリーン切り替え
engine->GetWinApp()->ToggleFullscreen();
```

### デフォルトの操作方法

- **F11キー**: フルスクリーン⇔ウィンドウモードを切り替え

## 技術的な詳細

### ボーダーレスウィンドウ方式とは

排他的フルスクリーンではなく、ボーダーレスウィンドウ方式を採用しています。

**メリット:**
- 切り替えが高速
- Alt+Tabでの切り替えがスムーズ
- マルチモニター環境で動作が安定
- DirectX12との互換性が高い

**デメリット:**
- 排他的フルスクリーンと比べて、ごくわずかなオーバーヘッドがある（通常は無視できるレベル）

### 使用するWindows API

| API | 用途 |
|-----|------|
| `GetWindowLong` / `SetWindowLong` | ウィンドウスタイルの取得・設定 |
| `GetWindowRect` | ウィンドウの位置とサイズを取得 |
| `MonitorFromWindow` | ウィンドウが表示されているモニターを取得 |
| `GetMonitorInfo` | モニターの解像度と作業領域を取得 |
| `SetWindowPos` | ウィンドウの位置・サイズ・Zオーダーを設定 |

### ウィンドウスタイルフラグ

- `WS_OVERLAPPEDWINDOW`: 通常のウィンドウ（タイトルバー、枠、最小化/最大化ボタン付き）
- `WS_VISIBLE | WS_POPUP`: ボーダーレスウィンドウ（枠なし）
- `HWND_TOPMOST`: 常に最前面に表示
- `HWND_NOTOPMOST`: 最前面から外す

### SetWindowPosフラグ

- `SWP_FRAMECHANGED`: ウィンドウフレームを再描画
- `SWP_SHOWWINDOW`: ウィンドウを表示

## カスタマイズ例

### 特定のキーでフルスクリーン切り替え

```cpp
// UnoEngine::Update() 内
if (input_->TriggerKey(DIK_F)) {  // Fキーで切り替え
    winApp_->ToggleFullscreen();
}
```

### ゲーム起動時にフルスクリーンで開始

```cpp
// UnoEngine::Initialize() の最後に追加
void UnoEngine::Initialize() {
    // ... 既存の初期化処理 ...

    // フルスクリーンで起動
    winApp_->ToggleFullscreen();
}
```

### フルスクリーン状態をUIで表示

```cpp
// ImGuiでの表示例
#ifdef _DEBUG
void ShowFullscreenStatus() {
    ImGui::Begin("表示モード");
    bool isFullscreen = engine->GetWinApp()->IsFullscreen();
    ImGui::Text("フルスクリーン: %s", isFullscreen ? "有効" : "無効");
    if (ImGui::Button("切り替え")) {
        engine->GetWinApp()->ToggleFullscreen();
    }
    ImGui::End();
}
#endif
```

## トラブルシューティング

### 問題1: フルスクリーン時に解像度がおかしい

**原因**: モニター情報の取得に失敗している可能性があります。

**解決策**: `MONITOR_DEFAULTTONEAREST`を使用してみてください。

```cpp
HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
```

### 問題2: フルスクリーンから戻れない

**原因**: ウィンドウスタイルまたは矩形の保存に失敗している可能性があります。

**解決策**: デフォルト値で復元するフォールバック処理を追加します。

```cpp
if (windowedRect_.right == 0) {
    // デフォルト値を設定
    windowedRect_ = { 0, 0, 1280, 720 };
}
```

### 問題3: マルチモニター環境で意図しないモニターにフルスクリーン表示される

**原因**: `MONITOR_DEFAULTTOPRIMARY`がプライマリモニターを返しています。

**解決策**: 現在ウィンドウが表示されているモニターを取得します（既に実装済み）。

```cpp
HMONITOR hMonitor = MonitorFromWindow(hwnd, MONITOR_DEFAULTTONEAREST);
```

## まとめ

UnoEngineのフルスクリーン実装は、ボーダーレスウィンドウ方式を採用しており、以下の特徴があります：

1. **高速な切り替え**: ウィンドウスタイルの変更のみで実現
2. **状態の保存と復元**: ウィンドウモード時の設定を保持
3. **マルチモニター対応**: 現在のモニターに応じて自動調整
4. **簡単な操作**: F11キーで即座に切り替え可能

この実装は、Windows APIの`SetWindowPos`と`SetWindowLong`を活用し、DirectX12との互換性を保ちながら、快適なフルスクリーン体験を提供します。
